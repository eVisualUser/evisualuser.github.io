<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Self</title>
        <link rel="stylesheet" href="../styles.css"/>
    </head>
    <body>
        <h1>Pretty-Engine</h1>
        <img class="state" alt="lock" src="../assets/lock.svg"/>

        <div class="content-section">
            <h2>Why ?</h2>
            <p>
                This is the most important question, and here it's performances and architecture.
                I need an engine to build games with great performances by default.
                <br/><br/>
                And in the other hand, I want to learn how to build it, to improve my skills in general programming.
                As it is also a goal for me to become in the future a Game Engine programmer.
                This one told me a lot, about how to play with memory, to writing flexible and robust code.
                By exploring features like multi-threading, SIMD,
                Vulkan and OpenGL,
                I build a range of competencies allowing to be efficient in most contexts.
                <br/><br/>
                I don't have a date for the end of the development, because I still have too much to learn.
                But when I will succeed to release a game using this engine, I will close the devlopement of this one(except if the result is greater than excepted).
            </p>
        </div>

        <div class="content-section">
            <h2>Current state of devlopement.</h2>
            <p>
                Currently, the engines have a good reflection system (currently being improved), with a multithreaded initialization.
                The asset manager is working well, but the bundle support is not complete (for release only).
                The input system is complete.
                <br/><br/>
                I rewrited for the third time the renderer after trying with OpenGL and Vulkan.
                But since using I was learning Vulkan at the same time,
                I have to rewrite it to have something more flexible and robust.
                <br/><br/>
                The architecture choosed for the user side, is the combination of three solutions:
            </p>
            <ul>
                <li>DynamicObject equivalent of GameObjects.</li>
                <li>Entity Component System.</li>
                <li>Process created at the initialization and destroyed at the end only.</li>
            </ul>
            <p>
                You got also reflected configurations inspired by the UDataAssets from Unreal Engine(equivalent of ScriptableObject in Unity).
            </p>
        </div>

        <div class="content-section">
            <h2>The difficulties</h2>
            Writing a game engine come with a lot of challenges.
            The biggest source of them is the requirement of knowledge about every aspect of this one.
            <br/><br/>
            For example my first version was working, but it was not at all maintainable.
            And adding new feature became a nightmare.
            The reason of it was the way objects where managed,
            without a garbage collector allowing to clear instances out of scope,
            caused to have many memory leaks (even if I was using smart pointers).
            <br/><br/>
            Also I didn't implemented well my reflection system, so it was consume a lot of memory.
            But it was reliable, compared to the current one that play with the limits of the C++.
            Making it having a lot of special cases to consider.
            Currently causing troubles.
            <br/><br/>
            For the asset management it's kinda similar to what I do right now,
            except I use compression and have a better support to store metadata.
            And the bundle support on the way.
            Bundles are going to be in release only, this will allow to compress multiple file at the same time,
            allowing to reduce file size, and having an exported build with less files for maintenance.
            <br/><br/>
            Multithreading is also a big difference, in the first try I written almost single threaded.
            But with a basic multithreading support that was efficient on the user side, but not in the engine.
            But now everything that tale time is multithreaded, and the architecture is made for it.
            With initializers and having tasks running async while the rendering is happening and in the future the physics.
        </div>

        <div class="content-section">
            <h2>Dependencies</h2>
            <table>
                <tr>
                   <td>Name</td>
                   <td>Use case</td>
                </tr>
                <tr>
                    <td><a href="https://vulkan.lunarg.com/sdk/home" class="link">Vulkan (LunarXG)</a></td>
                    <td>Graphic API</td>
                </tr>
                <tr>
                    <td><a href="https://github.com/g-truc/glm" class="link">GLM</a></td>
                    <td>Linear Algebra math library</td>
                </tr>
                <tr>
                    <td><a href="https://www.glfw.org/" class="link">GLFW</a></td>
                    <td>Window API</td>
                </tr>
                <tr>
                    <td><a href="https://github.com/zeux/pugixml" class="link">PUGIXML</a></td>
                    <td>XML Parser</td>
                </tr>
                <tr>
                    <td><a href="https://github.com/lz4/lz4" class="link">LZ4</a></td>
                    <td>Compression algorithm</td>
                </tr>
                <tr>
                    <td><a href="https://github.com/syoyo/tinygltf" class="link">TinyGLTF</a></td>
                    <td>GLTF file parser</td>
                </tr>
            </table>
        </div>
    </body>
</html>
